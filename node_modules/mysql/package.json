{
  "author": {
    "name": "Felix Geisend√∂rfer",
    "email": "felix@debuggable.com",
    "url": "http://debuggable.com/"
  },
  "name": "mysql",
  "description": "A node.js driver for mysql. It is written in JavaScript, does not require compiling, and is 100% MIT licensed.",
  "version": "2.0.0-alpha2",
  "repository": {
    "url": ""
  },
  "main": "./index",
  "scripts": {
    "test": "make test"
  },
  "engines": {
    "node": "*"
  },
  "dependencies": {
    "require-all": "0.0.3"
  },
  "devDependencies": {
    "utest": "0.0.6",
    "urun": "0.0.6",
    "underscore": "1.3.1"
  },
  "optionalDependencies": {},
  "readme": "# node-mysql\n\n[![Build Status](https://secure.travis-ci.org/felixge/node-mysql.png?branch=v2.0)](http://travis-ci.org/felixge/node-mysql)\n\n## Introduction\n\nThis is a node.js driver for mysql. It is written in JavaScript, does not\nrequire compiling, and is 100% MIT licensed.\n\nHere is an example on how to use it:\n\n```js\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'me',\n  password : 'secret',\n});\n\nconnection.connect();\n\nconnection.query('SELECT 1', function(err, rows, fields) {\n  if (err) throw err;\n\n  console.log('Query result: ', rows);\n});\n\nconnection.end();\n```\n\nFrom this example, you can learn the following:\n\n* Every method you invoke on a connection is queued and executed in sequence.\n* Closing the connection is done using `end()` which makes sure all remaining\n  queries are executed before sending a quit packet to the mysql server.\n\n## Contributors\n\nThanks goes to the people who have contributed code to this module, see the\n[GitHub Contributors page][].\n\n[GitHub Contributors page]: https://github.com/felixge/node-mysql/graphs/contributors\n\nAdditionally I'd like to thank the following people:\n\n* [Andrey Hristov][] (Oracle) - for helping me with protocol questions.\n* [Ulf Wendel][] (Oracle) - for helping me with protocol questions.\n\n[Ulf Wendel]: http://blog.ulf-wendel.de/\n[Andrey Hristov]: http://andrey.hristov.com/\n## Sponsors\n\nThe following companies have supported this project financially, allowing me to\nspend more time on it (ordered by time of contribution):\n\n* [Joyent](http://www.joyent.com/)\n* [pinkbike.com](http://pinkbike.com/)\n* [Holiday Extras](http://www.holidayextras.co.uk/) (they are [hiring](http://join.holidayextras.co.uk/vacancy/senior-web-technologist/))\n* [Newscope](http://newscope.com/) (they are [hiring](http://www.newscope.com/stellenangebote))\n\nIf you are interested in sponsoring a day or more of my time, please\n[get in touch][].\n\n[get in touch]: http://felixge.de/consulting\n\n## Community\n\nSo far all community activity has happened via the GitHub Issue system, however\nadditionally I have just started a mailing list and IRC channel where people\ncan ask questions and discuss things:\n\n* **Mailing list**: https://groups.google.com/forum/#!forum/node-mysql\n* **IRC Channel**: #node-mysql (on freenode.net)\n\n## Establishing connections\n\nThe recommended way to establish a connection is this:\n\n```js\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n  host       : String, // defaults to 'localhost'\n  port       : Number, // defaults to 3306\n  socketPath : String, // defaults to undefined\n  user       : String, // defaults to undefined\n  password   : String, // defaults to undefined\n  database   : String, // defaults to undefined\n  charset    : String, // defaults to 'UTF8_GENERAL_CI'\n  typeCast   : Boolean, // defaults to true\n  debug      : Boolean, // defaults to false\n});\n\nconnection.connect(function(err) {\n  // connected! (unless `err` is set)\n});\n```\n\nHowever, a connection can also be implicitly established by invoking a query:\n\n```js\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection(...);\n\nconnection.query('SELECT 1', function(err, rows) {\n  // connected! (unless `err` is set)\n});\n```\n\nDepending on how you like to handle your errors, either method may be\nappropriate. Any type of connection error (handshake or network) is considered\na fatal error, see the [Error Handling](#error-handling) section for more\ninformation.\n\n## Terminating connections\n\nThere are two ways to end a connection. Terminating a connection gracefully is\ndone by calling the `end()` method:\n\n```js\nconnection.end(function(err) {\n  // The connection is terminated now\n});\n```\n\nThis will make sure all previously enqueued queries are still before sending a\n`COM_QUIT` packet to the MySQL server. If a fatal error occurs before the\n`COM_QUIT` packet can be sent, an `err` argument will be provided to the\ncallback, but the connection will be terminated regardless of that.\n\nAn alternative way to end the connection is to call the `destroy()` method.\nThis will cause an immediate termination of the underlaying socket.\nAdditionally `destroy()` guarantees that no more events or callbacks will be\ntriggered for the connection.\n\n```js\nconnection.destroy();\n```\n\nUnlike `end()` the `destroy()` method does not take a callback argument.\n\n## Server disconnects\n\nYou may loose the connection to a MySQL server due to network problems, the\nserver timing you out, or the server crashing. All of these events are\nconsidered fatal errors, and will have the `err.code =\n'PROTOCOL_CONNECTION_LOST'`.  See the [Error Handling](#error-handling) section\nfor more information.\n\nThe best way to be notified about a connection termination is to listen for the\n`'close'` event:\n\n```js\nconnection.on('close', function(err) {\n  if (err) {\n    // We did not expect this connection to terminate\n    connection = mysql.createConnection(connection.config);\n  } else {\n    // We expected this to happen, end() was called.\n  }\n});\n```\n\nAs you can see in the example above, re-connecting a connection is done by\nestablishing a new connection. Once terminated, an existing connection object\ncannot be re-connected by design.\n\nPlease note that you will also receive a `'close'` event with an `err` argument\nwhen a connection attempt fails because of bad credentials. If you find this\ncumbersome to work with, please post to the node-mysql mailing list to discuss\nimprovements.\n\n## Escaping query values\n\nIn order to avoid SQL Injection attacks, you should always escape any user\nprovided data before using it inside a SQL query. You can do so using the\n`connection.escape()` method:\n\n```js\nvar userId = 'some user provided value';\nvar sql    = 'SELECT * FROM users WHERE id = ' + connection.escape(userId);\nconnection.query(sql, function(err, results) {\n  // ...\n});\n```\n\nAlternatively, you can use `?` characters as placeholders for values you would\nlike to have escaped like this:\n\n```js\nconnection.query('SELECT * FROM users WHERE id = ?', [userId], function(err, results) {\n  // ...\n});\n```\n\nThis looks similar to prepared statements in MySQL, however it really just uses\nthe same `connection.escape()` method internally.\n\nDifferent value types are escaped differently, here is how:\n\n* Numbers are left untouched\n* Booleans are converted to `true` / `false` strings\n* Date objects are converted to `'YYYY-mm-dd HH:ii:ss'` strings\n* Buffers are converted to hex strings, e.g. `X'0fa5'`\n* Strings are safely escaped\n* Arrays are turned into list, e.g. ['a', 'b'] turns into `'a', 'b'`\n* Objects are turned into `key = 'val'` pairs. Nested objects are cast to\n  strings.\n* `undefined` / `null` are converted to `NULL`\n* `NaN` / `Infinity` are left as-is. MySQL does not support these, and trying\n  to insert them as values will trigger MySQL errors until they implement\n  support.\n\nIf you paid attention, you may have noticed that this escaping allows you\nto do neat things like this:\n\n```js\nvar post  = {id: 1, title: 'Hello MySQL'};\nvar query = connection.query('INSERT INTO posts SET ?', post, function(err, result) {\n  // Neat!\n});\nconsole.log(query.sql); // INSERT INTO posts SET `id` = 1, `title` = 'Hello MySQL'\n\n```\n\n## Getting the id of an inserted row\n\nIf you are inserting a row into a table with an auto increment primary key, you\ncan retrieve the insert id like this:\n\n```js\nconnection.query('INSERT INTO posts SET ?', {title: 'test'}, function(err, result) {\n  if (err) throw err;\n\n  console.log(result.insertId);\n});\n```\n\n## Executing queries in parallel\n\nThe MySQL protocol is sequential, this means that you need multiple connections\nto execute queries in parallel. Future version of this module may ship with a\nconnection pool implementation, but for now you have to figure out how to\nmanage multiple connections yourself if you want to execute queries in\nparallel.\n\nOne simple approach is to create one connection per incoming http request.\n\n## Streaming query rows\n\nSometimes you may want to select large quantities of rows and process each of\nthem as they are received. This can be done like this:\n\n```js\nvar query = connection.query('SELECT * FROM posts');\nquery\n  .on('error', function(err) {\n    // Handle error, an 'end' event will be emitted after this as well\n  })\n  .on('fields', function(fields) {\n    // the field packets for the rows to follow\n  })\n  .on('result', function(row) {\n    // Pausing the connnection is useful if your processing involves I/O\n    connection.pause();\n\n    processRow(row, function() {\n      connection.resume();\n    });\n  })\n  .on('end', function() {\n    // all rows have been received\n  });\n```\n\nPlease note a few things about the example above:\n\n* Usually you will want to receive a certain amount of rows before starting to\n  throttle the connection using `pause()`. This number will depend on the\n  amount and size of your rows.\n* `pause()` / `resume()` operate on the underlaying socket and parser. You are\n  guaranteed that no more `'result'` events will fire after calling `pause()`.\n* You MUST NOT provide a callback to the `query()` method when streaming rows.\n* The `'result'` event will fire for both rows as well as OK packets\n  confirming the success of a INSERT/UPDATE query.\n\nAdditionally you may be interested to know that it is currently not possible to\nstream individual row columns, they will always be buffered up entirely. If you\nhave a good use case for streaming large fields to and from MySQL, I'd love to\nget your thoughts and conributions on this.\n\n## Multiple statement queries\n\nSupport for multiple statements is disabled for security reasons (it allows for\nSQL injection attacks if values are not properly escaped). To use this feature\nyou have to enable it for your connection:\n\n```js\nvar connection = mysql.createConnection({multipleStatements: true});\n```\n\nOnce enabled, you can execute multiple statement queries like any other query:\n\n```js\nconnection.query('SELECT 1; SELECT 2', function(err, results) {\n  if (err) throw err;\n\n  // `results` is an array with one element for every statement in the query:\n  console.log(results[0]); // [{1: 1}]\n  console.log(results[1]); // [{2: 2}]\n});\n```\n\nAdditionally you can also stream the results of multiple statement queries:\n\n```js\nvar query = connection.query('SELECT 1; SELECT 2');\n\nquery\n  .on('fields', function(fields, index) {\n    // the fields for the result rows that follow\n  })\n  .on('result', function(row, index) {\n    // index refers to the statement this result belongs to (starts at 0)\n  });\n```\n\nIf one of the statements in your query causes an error, the resulting Error\nobject contains a `err.index` property which tells you which statement caused\nit. MySQL will also stop executing any remaining statements when an error\noccurs.\n\nPlease note that the interface for streaming multiple statement queries is\nexperimental and I am looking forward to feedback on it.\n\n## Stored procedures\n\nYou can call stored procedures from your queries as with any other mysql driver.\nIf the stored procedure produces several result sets, they are exposed to you\nthe same way as the results for multiple statement queries.\n\n## Joins with overlapping column names\n\nWhen executing joins, you are likely to get result sets with overlapping column\nnames.\n\nBy default, node-mysql will overwrite colliding column names in the\norder the columns are received from MySQL, causing some of the received values\nto be unavailable.\n\nHowever, you can also specify that you want your columns to be nested below\nthe table name like this:\n\n```js\nvar options = {sql: '...', nestTables: true};\nconnection.query(options, function(err, results) {\n  /* results will be an array like this now:\n  [{\n    table1: {\n      fieldA: '...',\n      fieldB: '...',\n    },\n    table2: {\n      fieldA: '...',\n      fieldB: '...',\n    },\n  }, ...]\n  */\n});\n```\n\n## Error handling\n\nThis module comes with a consistent approach to error handling that you should\nreview carefully in order to write solid applications.\n\nAll errors created by this module are instances of the JavaScript [Error][]\nobject. Additionally they come with two properties:\n\n* `err.code`: Either a [MySQL server error][] (e.g.\n  `'ER_ACCESS_DENIED_ERROR'`), a node.js error (e.g. `'ECONNREFUSED'`) or an\n  internal error (e.g.  `'PROTOCOL_PARSER_EXCEPTION'`).\n* `err.fatal`: Boolean, indicating if this error is terminal to the connection\n  object.\n\n[Error]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error\n[MySQL server error]: http://dev.mysql.com/doc/refman/5.5/en/error-messages-server.html\n\nFatal errors are propagated to *all* pending callbacks. In the example below, a\nfatal error is triggered by trying to connect to an invalid port. Therefore the\nerror object is propagated to both pending callbacks:\n\n```js\nvar connection = require('mysql').createConnection({\n  port: 84943, // WRONG PORT\n});\n\nconnection.connect(function(err) {\n  console.log(err.code); // 'ECONNREFUSED'\n  console.log(err.fatal); // true\n});\n\nconnection.query('SELECT 1', function(err) {\n  console.log(err.code); // 'ECONNREFUSED'\n  console.log(err.fatal); // true\n});\n```\n\nNormal errors however are only delegated to the callback they belong to.  So in\nthe example below, only the first callback receives an error, the second query\nworks as expected:\n\n```js\nconnection.query('USE name_of_db_that_does_not_exist', function(err, rows) {\n  console.log(err.code); // 'ER_BAD_DB_ERROR'\n});\n\nconnection.query('SELECT 1', function(err, rows) {\n  console.log(err); // null\n  console.log(rows.length); // 1\n});\n```\n\nLast but not least: If a fatal errors occurs and there are no pending\ncallbacks, or a normal error occurs which has no callback belonging to it, the\nerror is emitted as an `'error'` event on the connection object. This is\ndemonstrated in the example below:\n\n```js\nconnection.on('error', function(err) {\n  console.log(err.code); // 'ER_BAD_DB_ERROR'\n});\n\nconnection.query('USE name_of_db_that_does_not_exist');\n```\n\nNote: `'error'` are special in node. If they occur without an attached\nlistener, a stack trace is printed and your process is killed.\n\n**tl;dr:** This module does not want you to to deal with silent failures. You\nshould always provide callbacks to your method calls. If you want to ignore\nthis advice and suppress unhandled errors, you can do this:\n\n```js\n// I am Chuck Noris:\nconnection.on('error', function() {});\n```\n\n## Type casting\n\nFor your convenience, this driver will cast mysql types into native JavaScript\ntypes by default. The following mappings exist:\n\n### Number\n\n* TINYINT\n* SMALLINT\n* INT\n* MEDIUMINT\n* YEAR\n* FLOAT\n* DOUBLE\n\n### Date\n\n* TIMESTAMP\n* DATE\n* DATETIME\n\n### Buffer\n\n* TINYBLOB\n* MEDIUMBLOB\n* LONGBLOB\n* BLOB\n* BINARY\n* VARBINARY\n* BIT (last byte will be filled with 0 bits as neccessary)\n\n### String\n\n* CHAR\n* VARCHAR\n* TINYTEXT\n* MEDIUMTEXT\n* LONGTEXT\n* TEXT\n* ENUM\n* SET\n* DECIMAL (may exceed float precision)\n* BIGINT (may exceed float precision)\n* TIME (could be mapped to Date, but what date would be set?)\n* GEOMETRY (never used those, get in touch if you do)\n\nIt is not recommended (and may go away / change in the future) to disable type\ncasting, but you can currently do so on either the connection:\n\n```js\nvar connection = require('mysql').createConnection({typeCast: false});\n```\n\nOr on the query level:\n\n```js\nvar options = {sql: '...', typeCast: false};\nvar query = connection.query(options, function(err, results) {\n\n}):\n```\n\n## Debugging and reporting problems\n\nIf you are running into problems, one thing that may help is enabling the\n`debug` mode for the connection:\n\n```js\nvar connection = mysql.createConnection({debug: true});\n```\n\nThis will print all incoming and outgoing packets on stdout.\n\nIf that does not help, feel free to open a GitHub issue. A good GitHub issue\nwill have:\n\n* The minimal amount of code required to reproduce the problem (if possible)\n* As much debugging output and information about your environment (mysql\n  version, node version, os, etc.) as you can gather.\n\n## FAQ\n\nI have yet to write this, but it will include:\n\n* What benefits does this driver have over compiled alternatives? (portability,\n  license, docs)\n* How is the performance of this module compared to the alternatives? (great)\n* Is there commercial support for this driver? (nodefirm?)\n* What features are missing? (stored procedures, transactions, pause, etc.)\n* How can I contribute? (explain)\n* What are the goals of this project?\n\n## Todo\n\n* Prepared statements\n* setTimeout() for Connection / Query\n* connection pooling\n* Support for encodings other than UTF-8 / ASCII\n* API support for transactions, similar to [php](http://www.php.net/manual/en/mysqli.quickstart.transactions.php)\n",
  "readmeFilename": "Readme.md",
  "_id": "mysql@2.0.0-alpha2",
  "_from": "mysql@2.0.0-alpha2"
}
